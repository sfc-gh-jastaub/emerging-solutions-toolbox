import pickle

func = pickle.loads(bytes.fromhex('800595b83e0000000000008c17636c6f75647069636b6c652e636c6f75647069636b6c65948c0e5f6d616b655f66756e6374696f6e9493942868008c0d5f6275696c74696e5f747970659493948c08436f6465547970659485945294284b034b004b004b524b1c4b0342901300007400a001a1007d037c03a0026401a1017d047403a00464026403a1027d057c0172667c00a00574069b00640474079b009d03a101a0087409a00a6405a1017409a00b7c01a1016b027409a00a6406a10164076b024000a1017d067c06a00c6405a101a00d7409a00e6408a101a00f6409a101a1016a107c0664056701640a640b8d03a0087409a00a6408a1017409a00a6409a1016b02a101a011a1007d077c0772617c07640c1900640819007d087412a0137c07640c1900640d1900a1017d026e077c01640e640f9c02530064107d087c0264111900640417007c02641219001700640417007c026413190017007d097c0264141900640417007c02641519001700640417007c026416190017007d0a7c02641719007d0b7c02641819007d0c7c02641919007d0d7c02641a19007d0e7c02641b19007d0f7c02641c19007d107c0f6400750072a667007d0f7c106400750072ac67007d10641d641e84007c02641f1900440083017d116420641e84007c02641f1900440083017d1269007c11a5017c12a5017d136421641e84007c02641f1900440083017d1469007c13a5017c14a5017d136422642384007c02641f1900440083017d157c02642419007d167c08640c6b0572fd7c02642519007d177c02642619007d187c169b0064047c179b0064047c189b009d057d197c00a0057c19a1016a147d1a6e1864277d1764287c049b0064297c059b009d047d187c169b0064047c179b0064047c189b009d057d196700642aa2017d1a7c00a0057c09a10189007c00a0057c0aa10189017c0b9001722a8800a0087409a0157c0ba101a10189007c0c900172358801a0087409a0157c0ca101a10189018800a016642b74096a177c0f8e00a10289008801a016642b74096a177c108e00a102890167007d1b74189b00642c7c049b00642d7c059b009d057d1c7c1b7c1c670117007d1b74096a197c1c7c0064076407642e74189b006404741a9b009d04642f8d056430741b6431741b6432741b660664336434840483017d1d7c006a1c67006435a2016701741da01e741da01f6436741da020a100a102741da01f642b741da021a100a102741da01f6437741da022a100a102741da01f6438741da023a100a102741da01f6439741da024643aa101a1026705a101643b8d02a0087409a00a6436a101a025a100a1017d1e74189b00643c7c049b00642d7c059b009d057d1f7c1b7c1f670117007d1b74096a197c1f7c0064076407642e74189b006404741a9b009d04642f8d056430741b6431741b6432741b6606643d643e840483017d2074189b00643f7c049b00642d7c059b009d057d217c1b7c21670117007d1b74096a197c217c0064076407642e74189b006404741a9b009d04642f8d056440741b6441741b6442741b6432741b660864436444840483017d2264457c157600900272bf8800a026642ba101a027a100a02864466447a1027d238801a026642ba101a027a100a02864466448a1027d247c236a107c24642b670164498d027d257c25a0297409a00b6445a101a00f6436a101642b7409a02a7409a00b6447a10164477409a00b6448a10164487409a00b644aa1017409a00a6448a1017409a00a6447a1011800a106a00f6437a101a1037d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c13644c1900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a02c7409a00b6700a1017409a02d7409a02e7409a00a6437a101644a1900a1017409a00a6437a101644b1900640c19006b046445a102a02f640ca101a102a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e644f7c157600900472537c13645019007d277c13645119007d2874096a327409a00b6452a1016701870066016453642384087c2744008301a20152008e007d298800a03364547409a0347c296455a102a1027d2a7c2aa0297c0d642b67011700645467011700a1017d2a74096a327409a00b6452a1016701870166016456642384087c2844008301a20152008e007d2b8801a03364577409a0347c2b6455a102a1027d2c7c2ca0297c0e642b67011700645767011700a1017d2c741b74357c0d7c0e830283017d2d6458a0106459642384007c2d44008301a1017d2e7c2a6a107c2c74367c2e8301645a645b8d037d2f7c2fa0087409a00a6454a1017409a00a6457a1016b03a1017d2f7c2fa0297c0e642b67011700a1017d2f7c00a037a1008f0c7d307c2fa011a10001005700640004000400830301006e093100900373607701010001000100590001007c306a38640c19006a397d31645c642384007c0e440083017d327c2fa033645d74096a2a7c328e00a1027d2f7c2fa026642ba101a027a100a0286446645ea1027d337c2fa00c642ba101a00d7409a03a645da101a00f645fa101a101a016645f7409a03b7409a00a645fa1017409a00b640ca1017409a00b6460a101a103a1027d347c336a107c34642b670164498d027d267c26a0297409a00b644fa101a00f6436a101642b7409a02a7409a00b6461a1017409a00b7c27a1017409a00b6462a1017409a00b7c28a1017409a00b645ea101645e7409a00b645fa101645f7409a00b6463a1017409a00b7c31a101a10aa00f6437a101a1037d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c1364641900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a02c7409a00b6700a1017409a02d7409a02e7409a00a6437a101645e1900a1017409a00a6437a101644b1900640c19006b046445a102a02f640ca101a102a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e64657c157600900472e07c13646619007d277c13646719007d286468642384007c27440083017d356469642384007c28440083017d36646a7d37646b7d38743c6465880088017c277c287c357c367c377c387c1c830a7d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c13646c1900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a03d7c1f7409a00a6437a101644a19007409a00a6437a101644b1900a103a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e646d7c1576009005726d7c13646e19007d277c13646f19007d286470642384007c27440083017d356471642384007c28440083017d3664727d3764737d38743c646d880088017c277c287c357c367c377c387c1c830a7d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c1364741900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a03d7c1f7409a00a6437a101644a19007409a00a6437a101644b1900a103a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e64757c157600900572fa7c13647619007d277c13647719007d286478642384007c27440083017d356479642384007c28440083017d36647a7d37647b7d38743c6475880088017c277c287c357c367c377c387c1c830a7d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c13647c1900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a03d7c1f7409a00a6437a101644a19007409a00a6437a101644b1900a103a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e647d7c15760090077254642e74189b006404741a9b009d047d3974189b00647e7c049b00642d7c059b009d057d3a74096a197c3a7c00640764077c39642f8d056430741b6431741b6432741b6606647f6480840483017d3b74189b0064817c049b00642d7c059b009d057d3c74096a197c3c7c00640764077c39642f8d056430741b6431741b6432741b660664826483840483017d3d74189b0064847c049b00642d7c059b009d057d3e74096a197c3e7c00640764077c39642f8d056430741b6431741b6432741b660664856486840483017d3f7c1b7c3a7c3c7c3e670317007d1b7c13648719007d277c13648819007d286489642384007c27440083017d35648a642384007c28440083017d36743e880088017c277c287c357c3683067d257c25a033648b7409a03d7c3a7409a00a648ca1017409a00a648da101a103a102a033648e7409a03d7c3c7409a00a648ca1017409a00a648da101a103a102a033648f7409a03d7c3e7409a00a648ca1017409a00a648da101a103a1027d407c40a0297409a00b647da101a00f6436a101642b7409a02a7409a00b6461a1017409a00b7c27a1017409a00b6462a1017409a00b7c28a1017409a00b648ba1017409a00a648ba1017409a00b648ea1017409a00a648ea1017409a00b648fa1017409a00a648fa101a10aa00f6437a101a1037d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c1364901900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a03d7c1f7409a00a6437a101648f19007409a00a6437a101644b1900a103a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e64917c15760090097289642e74189b006404741a9b009d047d3974189b0064927c049b00642d7c059b009d057d4174096a197c417c00640764077c39642f8d056430741b6431741b6432741b660664936494840483017d4274189b0064957c049b00642d7c059b009d057d4374096a197c437c00640764077c39642f8d056430741b6431741b6432741b660664966497840483017d447c1b7c417c43670217007d1b7c13649819007d277c13649919007d28743e880088017c277c28649a642384007c2744008301649b642384007c284400830183067d457c45a029642b7409a00b7c27a101a00f649ca1017409a00b7c28a101a00f649da1017409a00a648ca101a00f649ea1017409a00a648da101a00f649fa1017409a03d7c1c7409a00a648ca1017409a00a648da101a103a00f64a0a1017409a03d7c417409a00a648ca1017409a00a648da101a103a00f64a1a101a1077d46743e880088017c277c2864a2642384007c274400830164a3642384007c284400830183067d477c47a029642b7409a00a648ca101a00f64a4a1017409a00a648da101a00f64a5a1017409a03d7c1c7409a00a648ca1017409a00a648da101a103a00f64a6a1017409a03d7c437409a00a648ca1017409a00a648da101a103a00f64a7a101a1057d4864a8743f64a9741b64aa744064ab744064ac743f64327440660c64ad64ae84047d497c4964af7c2788007c4664b083057d4a7c4964b17c2888017c4664b083057d4b7c4a6a107c4b642b670164498d02a029642b7409a03d7c417409a00a64b2a1017409a00a64b3a101a103a00f64b4a101a1027d4c7c4964af7c2788007c4864b583057d4d7c4964b17c2888017c4864b583057d4e7c4d6a107c4e642b670164498d02a029642b7409a03d7c417409a00a64b2a1017409a00a64b3a101a103a00f64b6a101a1027d4f7c466a107c4c642b670164498d026a107c48642b670164498d026a107c4f642b670164498d02a04164a164a7a1027d507c50a0297409a00b6491a101a00f6436a101642b7409a02a7409a00b6461a1017409a00b7c27a1017409a00b6462a1017409a00b7c28a1017409a00b649ea1017409a00a649ea1017409a00b649fa1017409a00a649fa1017409a00b64a0a1017409a00a64a0a1017409a00b64b4a1017409a00a64b4a1017409a00b64a4a1017409a00a64a4a1017409a00b64a5a1017409a00a64a5a1017409a00b64a6a1017409a00a64a6a1017409a00b64b6a1017409a00a64b6a101a114a00f6437a101a1037d267c26a01664377409a02b7409a00a6437a1017409a00b644ba1017409a00b7c1364b71900a101a103a102a01664377409a02b7409a00a6437a1017409a00b644da1017409a03d7c217409a00a6437a10164a019007409a00a6437a10164a619007409a00a6437a101644b1900a104a103a102a01664387409a02d7409a0307409a00a6437a101644d1900a101640c6b046445a102a02f640ca101a102a01664397409a02d7409a00a6438a10164456b027409a00b644ea101a102a02f6400a101a1027d267c1ea0317c26a1017d1e7c1ea0297409a00b7c08a101a00f6408a1017409a00b7c03a101a00f64b8a1016436642b7409a00b7c09a101a00f64b9a1017409a00b7c0aa101a00f64baa101643764386439a109a0297c1aa101a0426436642ba1027d517c516a436a447c1964bb64bc8d0201007c197c167c177c187c017c087c157c1b64bd9c08530094284e8c1125595f256d5f25645f25485f254d5f2553944de8034d28238c012e948c084a4f425f4e414d45948c0949535f41435449564594888c064a4f425f4944948c0a4d41585f4a4f425f4944948c05696e6e6572948c026f6e948c03686f779486944b008c094a4f425f5350454353948c1d4e6f20616374697665206a6f627320776974682074686174206e616d6594680b8c054552524f529486944affffffff8c0f5441424c455f415f44425f4e414d45948c135441424c455f415f534348454d415f4e414d45948c0c5441424c455f415f4e414d45948c0f5441424c455f425f44425f4e414d45948c135441424c455f425f534348454d415f4e414d45948c0c5441424c455f425f4e414d45948c0e5441424c455f415f46494c544552948c0e5441424c455f425f46494c544552948c195441424c455f415f5245434f52445f49445f434f4c554d4e53948c195441424c455f425f5245434f52445f49445f434f4c554d4e53948c195441424c455f415f504152544954494f4e5f434f4c554d4e53948c195441424c455f425f504152544954494f4e5f434f4c554d4e53946807284b014b004b004b024b054b53432e69007c005d137d017c016400190064017601720264027c01640019009b0064039d037c016404190093027102530094288c0d434845434b5f545950455f4944944b0185948c07615f636865636b948c085f636f6c756d6e73948c0f5441424c455f415f434f4c554d4e53947494298c022e30948c05636865636b9486948c4d2f7661722f666f6c646572732f36792f707a76747433343937717131376d6c303974675f686d763430303030676e2f542f6970796b65726e656c5f34333031362f3239303336333436332e7079948c0a3c64696374636f6d703e944b45430a060002020c0114fe0602942929749452948c2564715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e3c64696374636f6d703e948c06434845434b53946807284b014b004b004b024b054b53682328682468258c07625f636865636b9468278c0f5441424c455f425f434f4c554d4e5394749429682c682d682e4b4b682f2929749452946807284b014b004b004b024b054b53432269007c005d0d7d0164007c01640119009b0064029d037c01640319009302710253009428682b68248c0b5f7468726573686f6c6473948c0f414c4552545f5448524553484f4c4494749429682c682d682e4b5743080600020214ff06ff942929749452946807284b014b004b004b024b044b53431467007c005d067d017c0164001900910271025300946824859429682c682d8c0a3c6c697374636f6d703e944b6143021400942929749452948c2564715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e3c6c697374636f6d703e948c0a524553554c54535f4442948c0e524553554c54535f534348454d41948c0e524553554c54535f54424c5f4e4d948c1454454d504f524152595f44515f4f424a45435453948c0554454d505f948c125f4e4f4e5f535441545f524553554c54535f9428680d8c0c52554e5f4441544554494d459468248c10504152544954494f4e5f56414c554553948c0e434f4e54524f4c5f54424c5f4e4d948c0e434f4d504152455f54424c5f4e4d948c07524553554c5453948c0a414c4552545f464c4147948c0c414c4552545f535441545553947494684e8c112e73756274726163745f6172726179735f948c055f7564665f948c014094288c046e616d65948c0773657373696f6e948c077265706c616365948c0c69735f7065726d616e656e74948c0e73746167655f6c6f636174696f6e9474948c0461727231948c0461727232948c0672657475726e946807284b024b004b004b024b044b53431464016402840074007c017c008302440083015300944e6807284b014b004b004b034b054b53433267007c005d155c027d017d027c01640075017c02640075014000721574007c017c021800640183026e016400910271025300944e4b0886948c05726f756e64948594682a8c0178948c0179948794682d68424b9c43023200942929749452948c3e64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e73756274726163745f6172726179732e3c6c6f63616c733e2e3c6c697374636f6d703e9487948c037a6970948594685e685f8694682d8c0f73756274726163745f617272617973944b9443021408942929749452948c2a64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e73756274726163745f61727261797394284e4e4e4e4e749468246851685268534bc88c06736368656d619485948c162e636f6d706172655f746f5f7468726573686f6c645f946807284b024b004b004b024b044b53431464016402840074007c007c018302440083015300944e6807284b014b004b004b034b044b53433867007c005d185c027d017d027c0164007500720c64016e0d7c0264007501721874007c0183017c026b04721864016e016402910271025300944e4b014b0087948c03616273948594682a68668c017a948794682d68424bbe43023800942929749452948c4364715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e636f6d706172655f746f5f7468726573686f6c642e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f6870682d8c14636f6d706172655f746f5f7468726573686f6c64944bb668722929749452948c2f64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e636f6d706172655f746f5f7468726573686f6c64948c1e2e636f6d706172655f6d696e5f6d61785f746f5f7468726573686f6c645f948c076d696e5f617272948c076d61785f617272948c0d7468726573686f6c645f617272946807284b034b004b004b034b054b53431664016402840074007c007c017c028303440083015300944e6807284b014b004b004b044b054b53434e67007c005d235c037d017d027d037c01640075007c02640075004200721164016e137c0364007501722374007c0183017c036b0474007c0283017c036b044200722364016e01640291027102530094687c687e28682a68666867687f7494682d68424bcd43024e00942929749452948c5264715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e636f6d706172655f6d696e5f6d61785f64656c7461735f746f5f7468726573686f6c642e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f688b688c688d8794682d8c23636f6d706172655f6d696e5f6d61785f64656c7461735f746f5f7468726573686f6c64944bc543021608942929749452948c3e64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e636f6d706172655f6d696e5f6d61785f64656c7461735f746f5f7468726573686f6c64944b018c05434f554e54948c115441424c455f415f524f575f434f554e54948c115441424c455f425f524f575f434f554e5494681085948c0544454c544194683b8c11636865636b315f7468726573686f6c6473948c14414c4552545f5452494747455245445f464c4147948c0e70656e64696e6720726576696577944b028c10615f636865636b325f636f6c756d6e73948c10625f636865636b325f636f6c756d6e73948c015f946807284b014b004b004b024b044b13431467007c005d067d0188007c011900910271025300942929682a8c03636f6c948694682d68424d250168438c0474626c6194859429749452948c0f415f4841534845445f434f4c554d4e944d00016807284b014b004b004b024b044b1368a7292968a9682d68424d300168438c0474626c6294859429749452948c0f425f4841534845445f434f4c554d4e948c03202620946807284b014b004b004b034b074b53432267007c005d0d5c027d017d0264007c019b0064017c029b0064029d05910271025300948c0b28615f6861736865645b27948c10275d203d3d20625f6861736865645b27948c03275d2994879429682a8c0161948c0162948794682d68424d3d0143022200942929749452948c065f425f54424c9468108c07727375666669789486946807284b014b004b004b034b064b53432a67007c005d117d017400a0017c01a1017400a0027c01a101660244005d047d027c029103710e7102530094298c0146948c036c69749468a88794682a8c05636f6c6e6d948c046974656d948794682d68424d4d01430a0600140104ff040108ff942929749452948c0b5245434f52445f44494354948c1d434f554e545f4f465f5245434f5244535f575f56414c55455f44494646948c225441424c455f425f4944535f575f56414c55455f444946465f4c494d49545f313030944b64682868358c0e53514c5f51554552595f54455854948c11636865636b325f7468726573686f6c6473944b038c10615f636865636b335f636f6c756d6e73948c10625f636865636b335f636f6c756d6e73946807284b014b004b004b024b054b53431c67007c005d0a7d017400a0017c01a101a0027c01a101910271025300942968c48c0373756d948c05616c696173948794682a68c78694682d68424da20143021c00942929749452946807284b014b004b004b024b054b5368d42968d768d8682d68424da30168d92929749452948c0c5441424c455f415f53554d53948c0c5441424c455f425f53554d53948c11636865636b335f7468726573686f6c6473944b048c10615f636865636b345f636f6c756d6e73948c10625f636865636b345f636f6c756d6e73946807284b014b004b004b024b094b53432e67007c005d137d017400a0017400a0027400a0037c01a101a004a1006400a102a101a0057c01a101910271025300948885942868c48c05636f756e74948c047768656e9468a88c0669734e756c6c9468d6749468d8682d68424dde0143080600020220ff06ff942929749452946807284b014b004b004b024b094b5368e368e468e868d8682d68424de20168e92929749452948c135441424c455f415f4e554c4c5f434f554e5453948c135441424c455f425f4e554c4c5f434f554e5453948c11636865636b345f7468726573686f6c6473944b058c10615f636865636b355f636f6c756d6e73948c10625f636865636b355f636f6c756d6e73946807284b014b004b004b024b054b5368d42968c48c0d636f756e7444697374696e63749468d6879468d8682d68424d220243060600100106ff942929749452946807284b014b004b004b024b054b5368d42968f468d8682d68424d250268f52929749452948c1d5441424c455f415f44495354494e43545f56414c55455f434f554e5453948c1d5441424c455f425f44495354494e43545f56414c55455f434f554e5453948c11636865636b355f7468726573686f6c6473944b068c152e66696e645f76616c7565735f64726f707065645f946807284b024b004b004b024b044b53687a4e6807284b014b004b004b034b064b53432467007c005d0e5c027d017d02740074017c01830174017c0283011800830191027102530094298c046c697374948c03736574948694682a8c027831948c027832948794682d68424d630243022400942929749452948c4264715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e66696e645f76616c7565735f64726f707065642e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f6870682d8c1366696e645f76616c7565735f64726f70706564944d610243021402942929749452948c2e64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e66696e645f76616c7565735f64726f70706564948c132e66696e645f76616c7565735f61646465645f946807284b024b004b004b024b044b53687a4e6807284b014b004b004b034b064b53432467007c005d0e5c027d017d02740074017c02830174017c0183011800830191027102530094296a010100006a04010000682d68424d68026a050100002929749452948c4064715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e66696e645f76616c7565735f61646465642e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f6870682d8c1166696e645f76616c7565735f6164646564944d66026a0b0100002929749452948c2c64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e66696e645f76616c7565735f6164646564948c102e66696e645f6e756d5f64696666735f946807284b024b004b004b024b044b53687a4e6807284b014b004b004b034b084b53434067007c005d1c5c027d017d027400740174027c01830174027c0283011800830183017400740174027c02830174027c018301180083018301170091027102530094298c036c656e9468ff6a0001000087946a04010000682d68424d6d0243024000942929749452948c3d64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e66696e645f6e756d5f64696666732e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f6870682d8c0e66696e645f6e756d5f6469666673944d6b026a0b0100002929749452948c2964715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e66696e645f6e756d5f6469666673948c10615f636865636b365f636f6c756d6e73948c10625f636865636b365f636f6c756d6e73946807284b014b004b004b024b054b5368d42968c48c0b636f6c6c6563745f7365749468d6879468d8682d68424d770268d92929749452946807284b014b004b004b024b054b5368d4296a2901000068d8682d68424d780268d92929749452948c0e56414c5545535f44524f50504544948c125441424c455f415f4147475f56414c554553948c125441424c455f425f4147475f56414c554553948c0c56414c5545535f4144444544948c154e554d4245525f4f465f444946464552454e434553948c11636865636b365f7468726573686f6c6473944b078c0d2e6765745f6d61785f6e756d73946807284b024b004b004b024b044b53687a4e6807284b014b004b004b034b054b53432e67007c005d135c027d017d027c01640075017c02640075014000721374007c017c0283026e016400910271025300944e85948c036d61789485946a04010000682d68424dcd0243022e00942929749452948c3b64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e6765745f6d61785f6e756d732e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f6870682d8c0c6765745f6d61785f6e756d73944dcb026a0b0100002929749452948c2764715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e6765745f6d61785f6e756d73948c0d2e6765745f6d696e5f6e756d73946807284b024b004b004b024b044b53687a4e6807284b014b004b004b034b054b536a350100006a360100008c036d696e9485946a04010000682d68424dd2026a390100002929749452948c3b64715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e6765745f6d696e5f6e756d732e3c6c6f63616c733e2e3c6c697374636f6d703e948794686f6870682d8c0c6765745f6d696e5f6e756d73944dd0026a0b0100002929749452948c2764715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e6765745f6d696e5f6e756d73948c10615f636865636b375f636f6c756d6e73948c10625f636865636b375f636f6c756d6e73946807284b014b004b004b024b054b5368d42968c46a4301000068d6879468d8682d68424de20268d92929749452946807284b014b004b004b024b054b5368d4296a4f01000068d8682d68424de30268d92929749452948c0a54424c5f415f434f4c53948c0a54424c5f425f434f4c53948c125441424c455f415f4d494e5f56414c554553948c125441424c455f425f4d494e5f56414c554553948c0944454c54415f4d494e948c0b5f4849474845525f4d494e946807284b014b004b004b024b054b5368d42968c46a3701000068d6879468d8682d68424df60268d92929749452946807284b014b004b004b024b054b5368d4296a5a01000068d8682d68424df70268d92929749452948c125441424c455f415f4d41585f56414c554553948c125441424c455f425f4d41585f56414c554553948c0944454c54415f4d4158948c0a5f4c4f5745525f4d4158948c0a74626c5f6c6574746572948c12636f6c735f746f5f636865636b5f6c697374948c08626173655f74626c948c0a64656c7461735f74626c948c0d6d696e735f6f725f6d61786573946807284b054b004b004b094b0d4b53421c01000067007d05740074017c018301830144005d617d067c017c0619007d077c04a002a10064016b02723c7c05a0037404a0057404a0067404a0077c07a1017404a00864027c069b0064039d03a1016b007404a0096404a101a102a00a7404a0096405a101a101a101a00b64067c079b009d02a101a101010071087c04a002a10064076b0272697c05a0037404a0057404a0067404a0077c07a1017404a00864087c069b0064039d03a1016b047404a0096404a101a102a00a7404a0096405a101a101a101a00b64097c079b009d02a101a101010071087c026a0c7c03640a6701640b8d02a00d640aa1016a0e7c058e007d087c08a00f640a74046a107c08a011640aa1016a128e00a00b640c7c009b00640d9d03a101a1027d087c08530094284e8c034d494e948c0c5f4849474845525f4d494e5b948c015d944b014b008c10434f554e545f4254574e5f4d494e535f948c034d4158948c0b5f4c4f5745525f4d41585b948c11434f554e545f4254574e5f4d415845535f94684e689f8c0454424c5f948c105f524f57535f4254574e5f434f554e54947494288c0572616e6765946a1b0100008c057570706572948c06617070656e649468c468d568e668a88c04657870729468c58c096f74686572776973659468d68c046a6f696e948c0867726f75705f6279948c03616767948c0673656c656374948c0f61727261795f636f6e737472756374948c0464726f70948c07636f6c756d6e73947494286a630100006a640100006a650100006a660100006a670100008c0d6167675f66756e635f6c697374948c01699468c78c0e636f756e74735f6274776e5f6466947494682d8c1d6765745f636f756e74735f6274776e5f6d696e735f6f725f6d61786573944d0403431c0401100108010c0150010c014e0102801c02040202011e0104fe0405942929749452948c3864715f6e6f6e5f737461745f7370726f632e3c6c6f63616c733e2e6765745f636f756e74735f6274776e5f6d696e735f6f725f6d61786573948c0141946a690100008c0142948c1554424c5f415f524f57535f4254574e5f434f554e54948c1554424c5f425f524f57535f4254574e5f434f554e54948c2e434f554e545f4f465f5245434f5244535f4254574e5f434f4e54524f4c5f414e445f434f4d504152455f4d494e53946a6d0100008c2f434f554e545f4f465f5245434f5244535f4254574e5f434f4e54524f4c5f414e445f434f4d504152455f4d41584553948c11636865636b375f7468726573686f6c647394684d684f68506a750100008c046d6f6465948594288c175155414c49464945445f524553554c545f54424c5f4e4d948c09524553554c545f4442948c0d524553554c545f534348454d41948c0d524553554c545f54424c5f4e4d94680b680d8c10434845434b535f504552464f524d4544948c095544465f4e414d45539474947494288c086461746574696d65948c036e6f77948c087374726674696d65948c0672616e646f6d948c0772616e64696e74948c057461626c65948c0d636f6e6669675f736368656d61948c0b6a6f62735f74626c5f6e6d948c0666696c7465729468c468a868c58c0767726f75704279946a7a0100006a3701000068d66a780100008c07636f6c6c656374948c046a736f6e948c056c6f616473946a7e0100006a760100008c0b776974685f636f6c756d6e946a7c0100008c1374656d705f6f626a656374735f736368656d61948c03756466948c0f74656d705f66696c655f73746167659468ff8c106372656174655f646174616672616d65948c0154948c0a53747275637454797065948c0b5374727563744669656c64948c0b496e746567657254797065948c09417272617954797065948c0b56617269616e7454797065948c084c6f6e6754797065948c0a537472696e6754797065948c0969734e6f744e756c6c946a7901000068e58c13776974685f636f6c756d6e5f72656e616d6564946a7b0100008c1a6f626a6563745f636f6e7374727563745f6b6565705f6e756c6c948c0d6f626a6563745f696e73657274948c0c61727261795f617070656e649468e6687d6a770100008c0961727261795f6d6178948c11756e696f6e5f616c6c5f62795f6e616d65948c09636f6e6361745f7773948c0a77697468436f6c756d6e948c047368613294686e8c046576616c948c0d71756572795f686973746f7279948c0771756572696573948c0873716c5f74657874948c0961727261795f616767948c0b61727261795f736c696365948c19636f6d706172655f636f6c756d6e5f61676772656761746573948c0863616c6c5f756466948c146765745f67726f75705f61676772656761746573948c03737472948c11536e6f777061726b446174614672616d65946a7d0100008c04736f7274948c057772697465948c0d736176655f61735f7461626c659474942868598c066a6f625f6e6d948c096a6f625f7370656373948c0872756e5f6474746d948c0c72756e5f6474746d5f737472948c0d72616e646f6d5f6e756d626572948c106163746976655f7265636f72645f6466948c0a6a6f625f7265636f7264948c066a6f625f6964948c1a615f7175616c69666965645f696e7075745f7461626c655f6e6d948c1a625f7175616c69666965645f696e7075745f7461626c655f6e6d948c10615f73716c5f66696c7465725f737472948c10625f73716c5f66696c7465725f737472948c10615f7265636f72645f69645f636f6c73948c10625f7265636f72645f69645f636f6c73948c10615f706172746974696f6e5f636f6c73948c10625f706172746974696f6e5f636f6c73948c10615f636865636b735f636f6c756d6e73948c10625f636865636b735f636f6c756d6e73948c0b636865636b5f7370656373948c10616c6572745f7468726573686f6c6473948c0d636865636b5f69645f6c697374948c0a726573756c74735f6462948c0e726573756c74735f736368656d61948c0e726573756c74735f74626c5f6e6d948c177175616c69666965645f726573756c745f74626c5f6e6d948c13726573756c74735f74626c5f636f6c756d6e73948c09756466735f6c697374948c067564665f6e6d9468718c0f756e696f6e65645f726573756c7473948c14616c6572745f636f6d706172655f7564665f6e6d9468868c1c616c6572745f6d696e5f6d61785f636f6d706172655f7564665f6e6d9468978c0b615f726f775f636f756e74948c0b625f726f775f636f756e74948c096a6f696e65645f6466948c09726573756c745f6466948c12615f636f6c756d6e735f746f5f636865636b948c12625f636f6c756d6e735f746f5f636865636b948c16615f636f6e636174656e617465645f636f6c756d6e73948c08615f686173686564948c16625f636f6e636174656e617465645f636f6c756d6e73948c08625f686173686564948c1163325f7a69707065645f69645f636f6c73948c1163325f6a6f696e5f636f6e646974696f6e948c0563325f6466948c07686973746f72799468d08c0769645f6c697374948c08636f756e745f6466948c066964735f6466948c0a615f6167675f6c697374948c0a625f6167675f6c697374948c0c615f6f75747075745f6b6579948c0c625f6f75747075745f6b6579948c0d7564665f73746167655f6c6f63948c1376616c735f64726f707065645f7564665f6e6d946a0a0100008c1176616c735f61646465645f7564665f6e6d946a150100008c106e756d5f64696666735f7564665f6e6d946a220100008c0864656c74615f6466948c0e6765745f6d61785f7564665f6e6d946a3e0100008c0e6765745f6d696e5f7564665f6e6d946a490100008c0e6a6f696e65645f64665f6d696e73948c0d64656c74615f64665f6d696e73948c0f6a6f696e65645f64665f6d61786573948c0e64656c74615f64665f6d61786573946a840100008c15615f636f756e74735f6274776e5f6d696e735f6466948c15625f636f756e74735f6274776e5f6d696e735f6466948c19636f6d62696e65645f636f756e74735f6274776e5f6d696e73948c16615f636f756e74735f6274776e5f6d617865735f6466948c16625f636f756e74735f6274776e5f6d617865735f6466948c1a636f6d62696e65645f636f756e74735f6274776e5f6d61786573948c0b636f6d62696e65645f6466948c0866696e616c5f6466947494682d8c1164715f6e6f6e5f737461745f7370726f63944b0142c404000008020a010c0204031202240102fe0206060112010a0104fd1604040102fa040a0c0114010204020106fe04050606020102ff060202fe020302fd060402fc02ff0608020102ff060202fe020302fd060402fc02ff08080801080208010802080108010401080104010603060206fe0606060206fe0c060606060206fe0c051205080308020801080114010e0104021001140108010a110a01060310010601100112031201040314030a01040202010201020102010e0104fb18070406080104010e020e010e010e01100102fb02ff04fe100b02f514120a01040202010201020102010e0104fb180714050a01040202010201020102010e0104fb1c070a0b08080401080102fd08060401080102fd100604020e010201040408010201080102010801120102fa060704f3021504010c0108010c0102fe02ff04050c010801400102fe02ff0405240102ff0403200102ff02f10a170a02080808010403080102ff100108ff04030c0104ff04040e0104ff0404080102ff100108ff04030c0104ff04040e0104ff0e0504010c0104ff14031a0310030a030a011eff0c020603020106ff120308040401080102fd08081201020102010401180102ff02fe02fd100b04020e0102010404080108010801080108010201080102010801080102f6060b04ef021904010c0108010c0102fe02ff04050c010801400102fe02ff0405240102ff0403200102ff02f10a170a02080608010e030e01040304010203020102010201020102010201020102010201020104f6021204010c0108010c0102fe02ff04050c010801200102fe02ff0405240102ff0403200102ff02f10a170a02080608010603020206fe0604020206fe040604010203020102010201020102010201020102010201020104f6021304010c0108010c0102fe02ff04050c010801200102fe02ff0405240102ff0403200102ff02f10a180a02080608010603020106ff0603020106ff040504010203020102010201020102010201020102010201020104f6021204010c0108010c0102fe02ff04050c010801200102fe02ff0405240102ff0403200102ff02f10a170a0210061402120118011403120118011403120118010e03080408010e030e01020402010201020102010201020104fa020902010201180102fe02030201180102fe02030201180102fe02f9040d0e0102010401080108010801080108010801080108010801080102f6060b04f2021704010c0108010c0102fe02ff04050c010801200102fe02ff0405240102ff0403200102ff02f10a170a0310061402120118011403120118010c0308040801020402010201020102010c010c0104fa040902010e010e010e010e011e011e0104f9020b02010201020102010c010c0104fa040902010e010e011e011e0104fb220a10131001100102011e0104fe10051001100102011e0104fe0406060104ff0202060104fd0204060104fb02060201020102fe02fa040d0e01020104010801080108010801080108010801080108010801080108010801080108010801080108010801080102ec061504e8022104010c0108010c0102fe02ff04050c0108012c0102fe02ff0405240102ff0403200102ff02f10a17040c0e010e01020102010e010e0102010201020102f7020b020102ff080302f110120203020102010201020102010201020106f8942968aa68af8694749452947d94288c0b5f5f7061636b6167655f5f944e8c085f5f6e616d655f5f948c085f5f6d61696e5f5f94754e4e4e749452948c1c636c6f75647069636b6c652e636c6f75647069636b6c655f66617374948c125f66756e6374696f6e5f73657473746174659493946a1f0200007d947d94286a1c0200006a150200008c0c5f5f7175616c6e616d655f5f946a150200008c0f5f5f616e6e6f746174696f6e735f5f947d948c0e5f5f6b7764656661756c74735f5f944e8c0c5f5f64656661756c74735f5f944e8c0a5f5f6d6f64756c655f5f946a1d0200008c075f5f646f635f5f944e8c0b5f5f636c6f737572655f5f944e8c175f636c6f75647069636b6c655f7375626d6f64756c6573945d948c0b5f5f676c6f62616c735f5f947d94286a9a0100006a9a0100008c086461746574696d659493946a9d01000068008c09737562696d706f72749493946a9d010000859452946aa00100008c06434f4e464947946aa10100008c0744515f4a4f42539468c46a340200008c1c736e6f77666c616b652e736e6f777061726b2e66756e6374696f6e7394859452946aa50100006a340200006aa5010000859452946aa8010000684a6aaa0100008c04434f4445946aac0100006a340200008c18736e6f77666c616b652e736e6f777061726b2e747970657394859452946ac40100008c1a7574696c6974795f66756e6374696f6e735f6e6f6e5f73746174946ac401000093946ac60100006a420200006ac601000093946ac80100008c1c736e6f77666c616b652e736e6f777061726b2e646174616672616d65948c09446174614672616d65949394757586948652302e'))
# The following comment contains the source code generated by snowpark-python for explanatory purposes.
# import json
# import random
# import snowflake.snowpark.functions as F
# import snowflake.snowpark.types as T
# from datetime import datetime
# from snowflake.snowpark.dataframe import DataFrame as SnowparkDataFrame
# from utility_functions_non_stat import compare_column_aggregates, get_group_aggregates
# config_schema  # variable of type <class 'str'>
# jobs_tbl_nm  # variable of type <class 'str'>
# temp_file_stage  # variable of type <class 'str'>
# temp_objects_schema  # variable of type <class 'str'>
# def dq_non_stat_sproc(session: Session, job_nm:str, job_specs: dict) -> dict:
#     # Create a string of the current datetime. This will be used to name temporary objects and will also be stored in results table.
#     run_dttm = datetime.now()
#     run_dttm_str = run_dttm.strftime("%Y_%m_%d_%H_%M_%S")
#
#     random_number = random.randint(1000, 9000)
#
#     # If a valid JOB_NAME is provided, procure the most current JOB_ID and JOB_SPECS for that job
#     if job_nm:
#         active_record_df = (
#             session.table(f"{config_schema}.{jobs_tbl_nm}")
#             .filter((F.col("JOB_NAME") == F.lit(job_nm)) & (F.col("IS_ACTIVE") == True))
#         )  # Obtain the ACTIVE Record for that JOB_NAME 
#
#         job_record = (
#             active_record_df
#             .groupBy("JOB_NAME")
#             .agg(F.max("JOB_ID").alias("MAX_JOB_ID"))
#             .join(active_record_df, on=["JOB_NAME"], how='inner')
#             .filter(F.col("JOB_ID")==F.col("MAX_JOB_ID"))
#             .collect()
#         ) # In the unexpected event that there is somehow more than one ACTIVE record for the given JOB_NAME, take the highest JOB_ID number
#
#         # If an active job is found in the DQ_JOBS table then get the JOB_ID and JOB_SPECS dictionary
#         if job_record:
#             job_id = job_record[0]["JOB_ID"]
#             job_specs = json.loads(job_record[0]["JOB_SPECS"])
#         else:
#             # If there were no active jobs in the DQ_JOBS table, then job_record will be an empty list. 
#             return {
#                 "JOB_NAME": job_nm,
#                 "ERROR": 'No active jobs with that name'
#             }
#     else:
#         job_id = -1
#
#     # *****************************************************
#     # Extract variables from the job_specs json
#     # *****************************************************
#     a_qualified_input_table_nm = (
#         job_specs["TABLE_A_DB_NAME"]
#         + "."
#         + job_specs["TABLE_A_SCHEMA_NAME"]
#         + "."
#         + job_specs["TABLE_A_NAME"]
#     )
#     b_qualified_input_table_nm = (
#         job_specs["TABLE_B_DB_NAME"]
#         + "."
#         + job_specs["TABLE_B_SCHEMA_NAME"]
#         + "."
#         + job_specs["TABLE_B_NAME"]
#     )
#
#     a_sql_filter_str = job_specs["TABLE_A_FILTER"]
#     b_sql_filter_str = job_specs["TABLE_B_FILTER"]
#
#     a_record_id_cols = job_specs["TABLE_A_RECORD_ID_COLUMNS"]
#     b_record_id_cols = job_specs["TABLE_B_RECORD_ID_COLUMNS"]
#
#     a_partition_cols = job_specs["TABLE_A_PARTITION_COLUMNS"]
#     b_partition_cols = job_specs["TABLE_B_PARTITION_COLUMNS"]
#     if a_partition_cols is None:
#         a_partition_cols = []
#     if b_partition_cols is None:
#         b_partition_cols = []
#
#     # Create a dictionary containing the columns to analyze for each check #TODO: Add an _ btwn check and the number so a_check1_columns becomes a_check_1_columns
#     a_checks_columns = {
#         f'a_check{check["CHECK_TYPE_ID"]}_columns': check["TABLE_A_COLUMNS"]
#         for check in job_specs["CHECKS"]
#         if check["CHECK_TYPE_ID"] not in [1]
#     }
#
#     b_checks_columns = {
#         f'b_check{check["CHECK_TYPE_ID"]}_columns': check["TABLE_B_COLUMNS"]
#         for check in job_specs["CHECKS"]
#         if check["CHECK_TYPE_ID"] not in [1]
#     }
#
#     check_specs = {**a_checks_columns, **b_checks_columns}
#
#
#     # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#     # ALERT THRESHOLDS
#     # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#     alert_thresholds = {
#         f'check{check["CHECK_TYPE_ID"]}_thresholds': check["ALERT_THRESHOLD"]
#         for check in job_specs["CHECKS"]
#     }
#
#     check_specs = {**check_specs, **alert_thresholds}
#     # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#     # Create a list of check ids for the given job. This will be used to only run checks that are in the list
#     check_id_list = [check["CHECK_TYPE_ID"] for check in job_specs["CHECKS"]]
#
#     # Specify where to write the results
#     results_db = job_specs["RESULTS_DB"]
#
#     if job_id >= 0:
#         results_schema = job_specs["RESULTS_SCHEMA"]
#         results_tbl_nm = job_specs["RESULTS_TBL_NM"]
#         qualified_result_tbl_nm = f"{results_db}.{results_schema}.{results_tbl_nm}"
#         results_tbl_columns = session.table(qualified_result_tbl_nm).columns
#     else:
#         results_schema = "TEMPORARY_DQ_OBJECTS"
#         results_tbl_nm = f"TEMP_{run_dttm_str}_NON_STAT_RESULTS_{random_number}"
#         qualified_result_tbl_nm = f"{results_db}.{results_schema}.{results_tbl_nm}"
#         results_tbl_columns = [
#             "JOB_ID",
#             "RUN_DATETIME",
#             "CHECK_TYPE_ID",
#             "PARTITION_VALUES",
#             "CONTROL_TBL_NM",
#             "COMPARE_TBL_NM",
#             "RESULTS",
#             "ALERT_FLAG", # NOTE: Added ALERT_FLAG and ALERT_STATUS to the results tables # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#             "ALERT_STATUS" # NOTE: Added ALERT_FLAG and ALERT_STATUS to the results tables # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         ]
#
#     # *****************************************************
#     # Establish base objects
#     # *****************************************************
#
#     # Establish Control and Comparison DataFrames for the 2 tables we're comparing
#     tbla = session.table(a_qualified_input_table_nm)
#     tblb = session.table(b_qualified_input_table_nm)
#
#     # Filter if a filter condition is specified
#     if a_sql_filter_str:
#         tbla = tbla.filter(F.expr(a_sql_filter_str))
#     if b_sql_filter_str:
#         tblb = tblb.filter(F.expr(b_sql_filter_str))
#
#     # Add an ARRAY column that holds the partion values
#     tbla = tbla.with_column("PARTITION_VALUES", F.array_construct(*a_partition_cols))
#     tblb = tblb.with_column("PARTITION_VALUES", F.array_construct(*b_partition_cols))
#
#     # Create a list to hold the names of any udfs we create
#     udfs_list = []
#
#     # Define and Register a UDF to subtract each value in two arrays of summary stats (like sum, null count, etc) to get a third array containing the changes
#     udf_nm = f"{temp_objects_schema}.subtract_arrays_{run_dttm_str}_udf_{random_number}"
#     udfs_list = udfs_list + [udf_nm]
#
#     @F.udf(
#         name=udf_nm,
#         session=session,
#         replace=True,
#         is_permanent=True,
#         stage_location=f"@{temp_objects_schema}.{temp_file_stage}",
#     )
#     def subtract_arrays(arr1: list, arr2: list) -> list:
#         return [round(x - y, 8) if (x is not None) & (y is not None) else None for x, y in zip(arr2, arr1)]
#
#
#     # Create an empty DataFrame to hold all the individual results 
#     # NOTE: Added ALERT_FLAG and ALERT_STATUS to the results tables # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#     unioned_results = session.create_dataframe(
#         [[None, None, None, None, None]], # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         schema=T.StructType(
#             [
#                 T.StructField("CHECK_TYPE_ID", T.IntegerType()),
#                 T.StructField("PARTITION_VALUES", T.ArrayType()),
#                 T.StructField("RESULTS", T.VariantType()),
#                 T.StructField("ALERT_FLAG", T.LongType()), # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#                 T.StructField("ALERT_STATUS", T.StringType(200)) # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#             ]
#         ),
#     ).filter(F.col("CHECK_TYPE_ID").isNotNull())
#
#
#     # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#     # UDF FOR ALERT THRESHOLD COMPARISONS
#     # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#     # Define and Register a UDF to compare the numbers in two arrays (used to compare deltas to alert threshold values)
#     alert_compare_udf_nm = f"{temp_objects_schema}.compare_to_threshold_{run_dttm_str}_udf_{random_number}"
#     udfs_list = udfs_list + [alert_compare_udf_nm]
#
#     @F.udf(
#         name=alert_compare_udf_nm,
#         session=session,
#         replace=True,
#         is_permanent=True,
#         stage_location=f"@{temp_objects_schema}.{temp_file_stage}",
#     )
#     def compare_to_threshold(arr1: list, arr2: list) -> list:
#         return [1 if (x is None) else 1 if (z is not None) and (abs(x) > z) else 0 for x, z in zip(arr1, arr2)]
#
#
#     # Define and Register a UDF to compare min and max deltas to the threshold
#     alert_min_max_compare_udf_nm = f"{temp_objects_schema}.compare_min_max_to_threshold_{run_dttm_str}_udf_{random_number}"
#     udfs_list = udfs_list + [alert_min_max_compare_udf_nm]
#
#     @F.udf(
#         name=alert_min_max_compare_udf_nm,
#         session=session,
#         replace=True,
#         is_permanent=True,
#         stage_location=f"@{temp_objects_schema}.{temp_file_stage}",
#     )
#     def compare_min_max_deltas_to_threshold(min_arr: list, max_arr: list, threshold_arr:list) -> list:
#         return [1 if (x is None) | (y is None) else 1 if (z is not None) and ((abs(x) > z) | (abs(y) > z)) else 0 for x, y, z in zip(min_arr, max_arr, threshold_arr)]
#     # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#
#     # *****************************************************
#     # Perform Checks
#     # *****************************************************
#
#     if (
#         1 in check_id_list
#     ):  # TODO: Maybe save a sproc for each check, and this pulls the correct sproc name from the DQ_JOBS table (instead of these IF blocks)
#         # *****************************************************
#         # CHECK 1: "table/partition total row count"
#         # *****************************************************
#
#         # Table A & B Row Counts
#         a_row_count = (
#             tbla.group_by("PARTITION_VALUES")
#             .count()
#             .with_column_renamed("COUNT", "TABLE_A_ROW_COUNT")
#         )
#         b_row_count = (
#             tblb.group_by("PARTITION_VALUES")
#             .count()
#             .with_column_renamed("COUNT", "TABLE_B_ROW_COUNT")
#         )
#         # Join the results into a single table
#         joined_df = a_row_count.join(b_row_count, on=["PARTITION_VALUES"])
#
#         result_df = joined_df.select(
#             F.lit(1).alias("CHECK_TYPE_ID"),
#             "PARTITION_VALUES",
#             # 'TABLE_A_ROW_COUNT',
#             # 'TABLE_B_ROW_COUNT',
#             # (F.col('TABLE_B_ROW_COUNT') - F.col('TABLE_A_ROW_COUNT')).alias("DELTA"),
#             F.object_construct_keep_null(
#                 F.lit("TABLE_A_ROW_COUNT"),
#                 "TABLE_A_ROW_COUNT",
#                 F.lit("TABLE_B_ROW_COUNT"),
#                 "TABLE_B_ROW_COUNT",
#                 F.lit("DELTA"),
#                 (F.col("TABLE_B_ROW_COUNT") - F.col("TABLE_A_ROW_COUNT")),
#             ).alias("RESULTS"),
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check1_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.array_append(F.lit([]), F.when(F.abs(F.col("RESULTS")["DELTA"]) > F.col("RESULTS")["ALERT_THRESHOLD"][0], 1).otherwise(0)))
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#     if 2 in check_id_list:
#         # *****************************************************
#         # CHECK 2: "record-level value change"
#         # *****************************************************
#
#         # TODO: Add error handling that confirms that the record_id columns are truly unique
#
#         # Establish columns this check will analyze
#         a_columns_to_check = check_specs["a_check2_columns"]
#         b_columns_to_check = check_specs["b_check2_columns"]
#
#         # Concatenate the selected columns into a single string and then hash
#         a_concatenated_columns = F.concat_ws(
#             F.lit("_"), *[tbla[col] for col in a_columns_to_check]
#         )
#         a_hashed = tbla.withColumn(
#             "A_HASHED_COLUMN", F.sha2(a_concatenated_columns, 256)
#         )
#         # a_hashed = a_hashed.select(a_record_id_cols + a_partition_cols + ["A_HASHED_COLUMN"])
#         a_hashed = a_hashed.select(
#             a_record_id_cols + ["PARTITION_VALUES"] + ["A_HASHED_COLUMN"]
#         )
#
#         b_concatenated_columns = F.concat_ws(
#             F.lit("_"), *[tblb[col] for col in b_columns_to_check]
#         )
#         b_hashed = tblb.withColumn(
#             "B_HASHED_COLUMN", F.sha2(b_concatenated_columns, 256)
#         )
#         # b_hashed = b_hashed.select(b_record_id_cols + b_partition_cols + ["B_HASHED_COLUMN"])
#         b_hashed = b_hashed.select(
#             b_record_id_cols + ["PARTITION_VALUES"] + ["B_HASHED_COLUMN"]
#         )
#
#         # Join the two hashed columns into a single table to compare
#         c2_zipped_id_cols = list(zip(a_record_id_cols, b_record_id_cols))
#         c2_join_condition = " & ".join(
#             [f"(a_hashed['{a}'] == b_hashed['{b}'])" for a, b in c2_zipped_id_cols]
#         )
#         c2_df = a_hashed.join(b_hashed, on=eval(c2_join_condition), rsuffix="_B_TBL")
#
#         # Only keep records that had a value change
#         c2_df = c2_df.filter(F.col("A_HASHED_COLUMN") != F.col("B_HASHED_COLUMN"))
#
#         # Only need the record id columns and the partition columns
#         c2_df = c2_df.select(b_record_id_cols + ["PARTITION_VALUES"])
#
#         # Obtain the query text that can be used to reproduce the records with changes
#         with session.query_history() as history:
#             c2_df.collect()
#         SQL_QUERY_TEXT = history.queries[0].sql_text
#
#         # Add a VARIANT column that is a dictionary of the B table record id(s)
#         id_list = [
#             item for colnm in b_record_id_cols for item in (F.lit(colnm), F.col(colnm))
#         ]
#         c2_df = c2_df.withColumn("RECORD_DICT", F.object_construct_keep_null(*id_list))
#
#         # df that contains the count of records with changes per partition
#         count_df = (
#             c2_df.group_by("PARTITION_VALUES")
#             .count()
#             .with_column_renamed("COUNT", "COUNT_OF_RECORDS_W_VALUE_DIFF")
#         )
#
#         # df that contains the record ids (limit 100) of records with changes per partition
#         ids_df = (
#             c2_df.groupBy("PARTITION_VALUES")
#             .agg(F.array_agg("RECORD_DICT").alias("TABLE_B_IDS_W_VALUE_DIFF_LIMIT_100"))
#             .with_column(
#                 "TABLE_B_IDS_W_VALUE_DIFF_LIMIT_100",
#                 F.array_slice(
#                     F.col("TABLE_B_IDS_W_VALUE_DIFF_LIMIT_100"), F.lit(0), F.lit(100)
#                 ),
#             )
#         )
#
#         result_df = count_df.join(ids_df, on=["PARTITION_VALUES"])
#
#         result_df = result_df.select(
#             F.lit(2).alias("CHECK_TYPE_ID"),
#             "PARTITION_VALUES",
#             # "COUNT_OF_RECORDS_W_VALUE_DIFF",
#             # "TABLE_B_IDS_W_VALUE_DIFF_LIMIT_100",
#             # F.lit(SQL_QUERY_TEXT).alias("SQL_QUERY_TEXT"),
#             F.object_construct_keep_null(
#                 F.lit("TABLE_A_COLUMNS"),
#                 F.lit(a_columns_to_check),
#                 F.lit("TABLE_B_COLUMNS"),
#                 F.lit(b_columns_to_check),
#                 F.lit("COUNT_OF_RECORDS_W_VALUE_DIFF"),
#                 "COUNT_OF_RECORDS_W_VALUE_DIFF",
#                 F.lit("TABLE_B_IDS_W_VALUE_DIFF_LIMIT_100"),
#                 "TABLE_B_IDS_W_VALUE_DIFF_LIMIT_100",
#                 F.lit("SQL_QUERY_TEXT"),
#                 F.lit(SQL_QUERY_TEXT),
#             ).alias("RESULTS"),
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check2_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.array_append(F.lit([]), F.when(F.abs(F.col("RESULTS")["COUNT_OF_RECORDS_W_VALUE_DIFF"]) > F.col("RESULTS")["ALERT_THRESHOLD"][0], 1).otherwise(0)))
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#     if 3 in check_id_list:
#         # *****************************************************
#         # CHECK 3: "column(s) sum"
#         # *****************************************************
#
#         # Establish columns this check will analyze
#         a_columns_to_check = check_specs["a_check3_columns"]
#         b_columns_to_check = check_specs["b_check3_columns"]
#
#         # Establish aggregate function that will be used on each partition
#         a_agg_list = [F.sum(colnm).alias(colnm) for colnm in a_columns_to_check]
#         b_agg_list = [F.sum(colnm).alias(colnm) for colnm in b_columns_to_check]
#
#         # Establish the names of the output keys
#         a_output_key = "TABLE_A_SUMS"
#         b_output_key = "TABLE_B_SUMS"
#
#         # Compare aggregate values for each column between the two tables by partition
#         result_df = compare_column_aggregates(
#             3,
#             tbla,
#             tblb,
#             a_columns_to_check,
#             b_columns_to_check,
#             a_agg_list,
#             b_agg_list,
#             a_output_key,
#             b_output_key,
#             udf_nm,
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check3_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.call_udf(alert_compare_udf_nm, F.col("RESULTS")["DELTA"], F.col("RESULTS")['ALERT_THRESHOLD']) )
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#     if 4 in check_id_list:
#         # *****************************************************
#         # CHECK 4: "column null count"
#         # *****************************************************
#
#         # Establish columns this check will analyze
#         a_columns_to_check = check_specs["a_check4_columns"]
#         b_columns_to_check = check_specs["b_check4_columns"]
#
#         # Establish aggregate function that will be used on each partition
#         a_agg_list = [
#             F.count(F.when(F.col(colnm).isNull(), True)).alias(colnm)
#             for colnm in a_columns_to_check
#         ]
#         b_agg_list = [
#             F.count(F.when(F.col(colnm).isNull(), True)).alias(colnm)
#             for colnm in b_columns_to_check
#         ]
#
#         # Establish the names of the output keys
#         a_output_key = "TABLE_A_NULL_COUNTS"
#         b_output_key = "TABLE_B_NULL_COUNTS"
#
#         # Compare aggregate values for each column between the two tables by partition
#         result_df = compare_column_aggregates(
#             4,
#             tbla,
#             tblb,
#             a_columns_to_check,
#             b_columns_to_check,
#             a_agg_list,
#             b_agg_list,
#             a_output_key,
#             b_output_key,
#             udf_nm,
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # TODO: Maybe add "KEY_THRESHOLD_IS_APPLIED_TO" in the job_specs dict for each check, so that instead of hard-coding "DELTA" below, it will apply the threshold to that key.
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check4_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.call_udf(alert_compare_udf_nm, F.col("RESULTS")["DELTA"], F.col("RESULTS")['ALERT_THRESHOLD']) )
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#     if 5 in check_id_list:
#         # *****************************************************
#         # CHECK 5: "column distinct value count"
#         # *****************************************************
#
#         # Establish columns this check will analyze
#         a_columns_to_check = check_specs["a_check5_columns"]
#         b_columns_to_check = check_specs["b_check5_columns"]
#
#         # Establish aggregate function that will be used on each partition
#         a_agg_list = [
#             F.countDistinct(colnm).alias(colnm) for colnm in a_columns_to_check
#         ]
#         b_agg_list = [
#             F.countDistinct(colnm).alias(colnm) for colnm in b_columns_to_check
#         ]
#
#         # Establish the names of the output keys
#         a_output_key = "TABLE_A_DISTINCT_VALUE_COUNTS"
#         b_output_key = "TABLE_B_DISTINCT_VALUE_COUNTS"
#
#         # Compare aggregate values for each column between the two tables by partition
#         result_df = compare_column_aggregates(
#             5,
#             tbla,
#             tblb,
#             a_columns_to_check,
#             b_columns_to_check,
#             a_agg_list,
#             b_agg_list,
#             a_output_key,
#             b_output_key,
#             udf_nm,
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check5_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.call_udf(alert_compare_udf_nm, F.col("RESULTS")["DELTA"], F.col("RESULTS")['ALERT_THRESHOLD']) )
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#     if 6 in check_id_list:
#         # *****************************************************
#         # CHECK 6: "column distinct values dropped or added"
#         # *****************************************************# 
#
#         # Define and Register UDFs to get the values dropped, values added, and number of differences
#         udf_stage_loc = f"@{temp_objects_schema}.{temp_file_stage}"
#
#         vals_dropped_udf_nm = f"{temp_objects_schema}.find_values_dropped_{run_dttm_str}_udf_{random_number}"
#         @F.udf(name=vals_dropped_udf_nm, session=session, replace=True, is_permanent=True, stage_location=udf_stage_loc)
#         def find_values_dropped(arr1: list, arr2: list) -> list:
#             return [list(set(x1)-set(x2)) for x1, x2  in zip(arr1, arr2)]
#
#         vals_added_udf_nm = f"{temp_objects_schema}.find_values_added_{run_dttm_str}_udf_{random_number}"
#         @F.udf(name=vals_added_udf_nm, session=session, replace=True, is_permanent=True, stage_location=udf_stage_loc)
#         def find_values_added(arr1: list, arr2: list) -> list:
#             return [list(set(x2)-set(x1)) for x1, x2 in zip(arr1, arr2)]
#
#         num_diffs_udf_nm = f"{temp_objects_schema}.find_num_diffs_{run_dttm_str}_udf_{random_number}"
#         @F.udf(name=num_diffs_udf_nm, session=session, replace=True, is_permanent=True, stage_location=udf_stage_loc)
#         def find_num_diffs(arr1: list, arr2: list) -> list:
#             return [len(list(set(x1)-set(x2))) + len(list(set(x2)-set(x1))) for x1, x2 in zip(arr1, arr2)]
#
#         udfs_list = udfs_list + [vals_dropped_udf_nm, vals_added_udf_nm, num_diffs_udf_nm]
#
#
#         # Establish columns this check will analyze
#         a_columns_to_check = check_specs["a_check6_columns"]
#         b_columns_to_check = check_specs["b_check6_columns"]
#
#         # Establish aggregate function that will be used to get the DISTINCT VALUES for each column in each partition
#         a_agg_list = [F.collect_set(colnm).alias(colnm) for colnm in a_columns_to_check]
#         b_agg_list = [F.collect_set(colnm).alias(colnm) for colnm in b_columns_to_check]
#
#
#         # Compare aggregate values for each column between the two tables by partition
#         joined_df = get_group_aggregates(
#             tbla,
#             tblb,
#             a_columns_to_check,
#             b_columns_to_check,
#             a_agg_list,
#             b_agg_list
#         )
#
#         delta_df = (joined_df
#                     .withColumn(
#                         "VALUES_DROPPED",
#                         F.call_udf(vals_dropped_udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES"))
#                     ).withColumn(
#                         "VALUES_ADDED",
#                         F.call_udf(vals_added_udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES"))
#                     ).withColumn(
#                         "NUMBER_OF_DIFFERENCES",
#                         F.call_udf(num_diffs_udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES"))
#                     )
#         )
#
#         result_df = delta_df.select(
#             F.lit(6).alias("CHECK_TYPE_ID"),
#             "PARTITION_VALUES",
#             F.object_construct_keep_null(
#                 F.lit("TABLE_A_COLUMNS"),
#                 F.lit(a_columns_to_check),
#                 F.lit("TABLE_B_COLUMNS"),
#                 F.lit(b_columns_to_check),
#                 F.lit("VALUES_DROPPED"),
#                 F.col("VALUES_DROPPED"),
#                 F.lit("VALUES_ADDED"),
#                 F.col("VALUES_ADDED"),
#                 F.lit("NUMBER_OF_DIFFERENCES"),
#                 F.col("NUMBER_OF_DIFFERENCES"),
#             ).alias("RESULTS"),
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check6_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.call_udf(alert_compare_udf_nm, F.col("RESULTS")["NUMBER_OF_DIFFERENCES"], F.col("RESULTS")['ALERT_THRESHOLD']) )
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#
#     if 7 in check_id_list:
#         # *****************************************************
#         # CHECK 7: "column min/max values"
#         # *****************************************************
#
#         # Define and Register UDFs to get the higher of two min valuess and the lower of two max values
#         udf_stage_loc = f"@{temp_objects_schema}.{temp_file_stage}"
#
#         get_max_udf_nm = f"{temp_objects_schema}.get_max_nums{run_dttm_str}_udf_{random_number}"
#         @F.udf(name=get_max_udf_nm, session=session, replace=True, is_permanent=True, stage_location=udf_stage_loc)
#         def get_max_nums(arr1: list, arr2: list) -> list:
#             return [max(x1, x2) if (x1 is not None) & (x2 is not None) else None for x1, x2  in zip(arr1, arr2)]
#
#         get_min_udf_nm = f"{temp_objects_schema}.get_min_nums{run_dttm_str}_udf_{random_number}"
#         @F.udf(name=get_min_udf_nm, session=session, replace=True, is_permanent=True, stage_location=udf_stage_loc)
#         def get_min_nums(arr1: list, arr2: list) -> list:
#             return [min(x1, x2) if (x1 is not None) & (x2 is not None) else None for x1, x2  in zip(arr1, arr2)]
#
#         udfs_list = udfs_list + [get_max_udf_nm, get_min_udf_nm]
#
#
#         # Establish columns this check will analyze
#         a_columns_to_check = check_specs["a_check7_columns"]
#         b_columns_to_check = check_specs["b_check7_columns"]
#
#
#         # Compare aggregate MIN values for each column between the two tables by partition
#         joined_df_mins = get_group_aggregates(
#             tbla,
#             tblb,
#             a_columns_to_check,
#             b_columns_to_check,
#             [F.min(colnm).alias(colnm) for colnm in a_columns_to_check],
#             [F.min(colnm).alias(colnm) for colnm in b_columns_to_check]
#         )
#
#         delta_df_mins = joined_df_mins.select(
#             "PARTITION_VALUES",
#             F.lit(a_columns_to_check).alias("TBL_A_COLS"),
#             F.lit(b_columns_to_check).alias("TBL_B_COLS"),
#             F.col("TABLE_A_AGG_VALUES").alias("TABLE_A_MIN_VALUES"),
#             F.col("TABLE_B_AGG_VALUES").alias("TABLE_B_MIN_VALUES"),
#             F.call_udf(udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES")).alias("DELTA_MIN"),
#             F.call_udf(get_max_udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES")).alias("_HIGHER_MIN")
#         )
#
#         # Compare aggregate MAX values for each column between the two tables by partition
#         joined_df_maxes = get_group_aggregates(
#             tbla,
#             tblb,
#             a_columns_to_check,
#             b_columns_to_check,
#             [F.max(colnm).alias(colnm) for colnm in a_columns_to_check],
#             [F.max(colnm).alias(colnm) for colnm in b_columns_to_check]
#         )
#
#         delta_df_maxes = joined_df_maxes.select(
#             "PARTITION_VALUES",
#             F.col("TABLE_A_AGG_VALUES").alias("TABLE_A_MAX_VALUES"),
#             F.col("TABLE_B_AGG_VALUES").alias("TABLE_B_MAX_VALUES"),
#             F.call_udf(udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES")).alias("DELTA_MAX"),
#             F.call_udf(get_min_udf_nm, F.col("TABLE_A_AGG_VALUES"), F.col("TABLE_B_AGG_VALUES")).alias("_LOWER_MAX")
#         )
#
#
#         # Obtain counts of rows that were between the two tables' min values and counts that were between the two tables max values.
#         def get_counts_btwn_mins_or_maxes(tbl_letter:str, cols_to_check_list:list, base_tbl:SnowparkDataFrame, deltas_tbl:SnowparkDataFrame, mins_or_maxes:str) -> SnowparkDataFrame:
#             agg_func_list = []
#             for i in range(len(cols_to_check_list)):
#                 colnm = cols_to_check_list[i]
#                 if mins_or_maxes.upper() == 'MIN':
#                     agg_func_list.append( F.sum( F.when(F.col(colnm) < F.expr(f'_HIGHER_MIN[{i}]'), F.lit(1)).otherwise(F.lit(0)) ).alias(f'COUNT_BTWN_MINS_{colnm}') )
#                 elif mins_or_maxes.upper() == 'MAX':
#                     agg_func_list.append( F.sum( F.when(F.col(colnm) > F.expr(f'_LOWER_MAX[{i}]'), F.lit(1)).otherwise(F.lit(0)) ).alias(f'COUNT_BTWN_MAXES_{colnm}') )
#
#             counts_btwn_df = base_tbl.join(deltas_tbl, on=['PARTITION_VALUES']).group_by('PARTITION_VALUES').agg(*agg_func_list)
#
#             counts_btwn_df = counts_btwn_df.select(
#                 "PARTITION_VALUES",
#                 F.array_construct(*counts_btwn_df.drop("PARTITION_VALUES").columns).alias(f"TBL_{tbl_letter}_ROWS_BTWN_COUNT")   
#             )
#
#             return counts_btwn_df
#
#
#         a_counts_btwn_mins_df = get_counts_btwn_mins_or_maxes('A', a_columns_to_check, tbla, delta_df_mins, 'MIN')
#         b_counts_btwn_mins_df = get_counts_btwn_mins_or_maxes('B', b_columns_to_check, tblb, delta_df_mins, 'MIN')
#         combined_counts_btwn_mins = a_counts_btwn_mins_df.join(b_counts_btwn_mins_df, on=['PARTITION_VALUES']).select(
#             "PARTITION_VALUES",
#             F.call_udf(get_max_udf_nm, F.col("TBL_A_ROWS_BTWN_COUNT"), F.col("TBL_B_ROWS_BTWN_COUNT")).alias("COUNT_OF_RECORDS_BTWN_CONTROL_AND_COMPARE_MINS")
#         )
#
#         a_counts_btwn_maxes_df = get_counts_btwn_mins_or_maxes('A', a_columns_to_check, tbla, delta_df_maxes, 'MAX')
#         b_counts_btwn_maxes_df = get_counts_btwn_mins_or_maxes('B', b_columns_to_check, tblb, delta_df_maxes, 'MAX')
#         combined_counts_btwn_maxes = a_counts_btwn_maxes_df.join(b_counts_btwn_maxes_df, on=['PARTITION_VALUES']).select(
#             "PARTITION_VALUES",
#             F.call_udf(get_max_udf_nm, F.col("TBL_A_ROWS_BTWN_COUNT"), F.col("TBL_B_ROWS_BTWN_COUNT")).alias("COUNT_OF_RECORDS_BTWN_CONTROL_AND_COMPARE_MAXES")
#         )
#
#
#         combined_df = delta_df_mins.join(
#             combined_counts_btwn_mins, on=['PARTITION_VALUES']
#         ).join(
#             delta_df_maxes, on=['PARTITION_VALUES']
#         ).join(
#             combined_counts_btwn_maxes, on=['PARTITION_VALUES']
#         ).drop(
#             "_HIGHER_MIN",
#             "_LOWER_MAX"
#         )
#
#
#
#         result_df = combined_df.select(
#             F.lit(7).alias("CHECK_TYPE_ID"),
#             "PARTITION_VALUES",
#             F.object_construct_keep_null(
#                 F.lit("TABLE_A_COLUMNS"),
#                 F.lit(a_columns_to_check),
#                 F.lit("TABLE_B_COLUMNS"),
#                 F.lit(b_columns_to_check),
#                 F.lit("TABLE_A_MIN_VALUES"),
#                 F.col("TABLE_A_MIN_VALUES"),
#                 F.lit("TABLE_B_MIN_VALUES"),
#                 F.col("TABLE_B_MIN_VALUES"),
#                 F.lit("DELTA_MIN"),
#                 F.col("DELTA_MIN"),
#                 F.lit("COUNT_OF_RECORDS_BTWN_CONTROL_AND_COMPARE_MINS"),
#                 F.col("COUNT_OF_RECORDS_BTWN_CONTROL_AND_COMPARE_MINS"),
#                 F.lit("TABLE_A_MAX_VALUES"),
#                 F.col("TABLE_A_MAX_VALUES"),
#                 F.lit("TABLE_B_MAX_VALUES"),
#                 F.col("TABLE_B_MAX_VALUES"),
#                 F.lit("DELTA_MAX"),
#                 F.col("DELTA_MAX"),
#                 F.lit("COUNT_OF_RECORDS_BTWN_CONTROL_AND_COMPARE_MAXES"),
#                 F.col("COUNT_OF_RECORDS_BTWN_CONTROL_AND_COMPARE_MAXES")
#             ).alias("RESULTS"),
#         )
#
#
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         # INCORPORATE ALERT THRESHOLDS
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#         result_df = (
#             result_df
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_THRESHOLD"), 
#                                         F.lit(check_specs["check7_thresholds"]))
#                         )
#             .with_column("RESULTS", 
#                         F.object_insert(F.col("RESULTS"), 
#                                         F.lit("ALERT_TRIGGERED_FLAG"), 
#                                         F.call_udf(alert_min_max_compare_udf_nm, F.col("RESULTS")["DELTA_MIN"], F.col("RESULTS")["DELTA_MAX"], F.col("RESULTS")['ALERT_THRESHOLD']) )
#                         )
#             .with_column("ALERT_FLAG", 
#                         F.when(F.array_max(F.col("RESULTS")["ALERT_TRIGGERED_FLAG"])>0, 1).otherwise(0)
#                         )
#             .with_column("ALERT_STATUS", 
#                         F.when(F.col("ALERT_FLAG")==1, F.lit("pending review")).otherwise(None)
#                         )
#         )
#         # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#
#
#         # Add results to the unioned_results DF
#         unioned_results = unioned_results.union_all_by_name(result_df)
#
#
#
#     # *****************************************************
#     # Write Results
#     # *****************************************************
#
#     # unioned_results = unioned_results.sort("CHECK_TYPE_ID", "PARTITION_VALUES")
#
#     # NOTE: Added ALERT_FLAG and ALERT_STATUS to the results tables # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#     final_df = (
#         unioned_results.select(
#             F.lit(job_id).alias("JOB_ID"),
#             F.lit(run_dttm).alias("RUN_DATETIME"),
#             "CHECK_TYPE_ID",
#             "PARTITION_VALUES",
#             F.lit(a_qualified_input_table_nm).alias("CONTROL_TBL_NM"),
#             F.lit(b_qualified_input_table_nm).alias("COMPARE_TBL_NM"),
#             "RESULTS",
#             "ALERT_FLAG", # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#             "ALERT_STATUS" # *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#         )
#         .select(
#             results_tbl_columns  # This second .select ensures the columns are in the correct order to be inserted into an existing table if job_id>=0
#         )
#         .sort("CHECK_TYPE_ID", "PARTITION_VALUES")
#     )
#
#     final_df.write.save_as_table(qualified_result_tbl_nm, mode="append")
#
#     return {
#         "QUALIFIED_RESULT_TBL_NM": qualified_result_tbl_nm,
#         "RESULT_DB": results_db,
#         "RESULT_SCHEMA": results_schema,
#         "RESULT_TBL_NM": results_tbl_nm,
#         "JOB_NAME": job_nm,
#         "JOB_ID": job_id,
#         "CHECKS_PERFORMED": check_id_list,
#         "UDF_NAMES": udfs_list
#     }
#
# func = dq_non_stat_sproc

def compute(session,arg1,arg2):
    return func(session,arg1,arg2)